var A = Object.defineProperty;
var w = (t, e, r) => e in t ? A(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var o = (t, e, r) => (w(t, typeof e != "symbol" ? e + "" : e, r), r);
import { HasuraAuthClient as U } from "@nhost/hasura-auth-js";
import p from "axios";
import { print as b } from "graphql";
import { HasuraStorageClient as m } from "@nhost/hasura-storage-js";
const S = /^((?<protocol>http[s]?):\/\/)?(?<host>localhost)(:(?<port>(\d+|__\w+__)))?$/;
function k(t, e) {
  const { backendUrl: r, subdomain: n, region: c } = t;
  if (r)
    return `${r}/v1/${e}`;
  if (!n)
    throw new Error("Either `backendUrl` or `subdomain` must be set.");
  const s = n.match(S);
  if (s != null && s.groups) {
    const { protocol: a = "http", host: u, port: i = 1337 } = s.groups, l = q(e);
    return l || `${a}://${u}:${i}/v1/${e}`;
  }
  if (!c)
    throw new Error('`region` must be set when using a `subdomain` other than "localhost".');
  return `https://${n}.${e}.${c}.nhost.run/v1`;
}
function E() {
  return typeof window < "u";
}
function v() {
  return typeof process < "u" && process.env;
}
function q(t) {
  return E() || !v() ? null : process.env[`NHOST_${t.toUpperCase()}_URL`];
}
function C(t) {
  const e = "subdomain" in t || "backendUrl" in t ? k(t, "auth") : t.authUrl;
  if (!e)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new U({ url: e, ...t });
}
function $(t) {
  const e = "subdomain" in t || "backendUrl" in t ? k(t, "functions") : t.functionsUrl;
  if (!e)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new _({ url: e, ...t });
}
class _ {
  constructor(e) {
    o(this, "url");
    o(this, "instance");
    o(this, "accessToken");
    o(this, "adminSecret");
    const { url: r, adminSecret: n } = e;
    this.url = r, this.accessToken = null, this.adminSecret = n, this.instance = p.create({
      baseURL: r
    });
  }
  async call(e, r, n) {
    const c = {
      ...this.generateAccessTokenHeaders(),
      ...n == null ? void 0 : n.headers
    };
    let s;
    try {
      s = await this.instance.post(e, r, { ...n, headers: c });
    } catch (a) {
      if (a instanceof Error)
        return { res: null, error: a };
    }
    return s ? { res: s, error: null } : {
      res: null,
      error: new Error("Unable to make post request to funtion")
    };
  }
  setAccessToken(e) {
    if (!e) {
      this.accessToken = null;
      return;
    }
    this.accessToken = e;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
}
function y(t) {
  const e = "subdomain" in t || "backendUrl" in t ? k(t, "graphql") : t.graphqlUrl;
  if (!e)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new H({ url: e, ...t });
}
class H {
  constructor(e) {
    o(this, "url");
    o(this, "instance");
    o(this, "accessToken");
    o(this, "adminSecret");
    const { url: r, adminSecret: n } = e;
    this.url = r, this.accessToken = null, this.adminSecret = n, this.instance = p.create({
      baseURL: r
    });
  }
  async request(e, r, n) {
    const c = {
      ...this.generateAccessTokenHeaders(),
      ...n == null ? void 0 : n.headers,
      "Accept-Encoding": "*"
    };
    try {
      const s = "", u = (await this.instance.post(
        "",
        {
          operationName: s || void 0,
          query: typeof e == "string" ? e : b(e),
          variables: r
        },
        { ...n, headers: c }
      )).data, { data: i } = u;
      return u.errors ? {
        data: null,
        error: u.errors
      } : typeof i != "object" || Array.isArray(i) || i === null ? {
        data: null,
        error: new Error("incorrect response data from GraphQL server")
      } : { data: i, error: null };
    } catch (s) {
      return s instanceof Error ? { data: null, error: s } : (console.error(s), {
        data: null,
        error: new Error("Unable to get do GraphQL request")
      });
    }
  }
  getUrl() {
    return this.url;
  }
  setAccessToken(e) {
    if (!e) {
      this.accessToken = null;
      return;
    }
    this.accessToken = e;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
}
function N(t) {
  const e = "subdomain" in t || "backendUrl" in t ? k(t, "storage") : t.storageUrl;
  if (!e)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new m({ url: e, ...t });
}
const B = (t) => new G(t);
class G {
  constructor({
    refreshIntervalTime: e,
    clientStorageGetter: r,
    clientStorageSetter: n,
    clientStorage: c,
    clientStorageType: s,
    autoRefreshToken: a,
    autoSignIn: u,
    adminSecret: i,
    devTools: l,
    start: g = !0,
    ...d
  }) {
    o(this, "auth");
    o(this, "storage");
    o(this, "functions");
    o(this, "graphql");
    o(this, "_adminSecret");
    o(this, "devTools");
    this.auth = C({
      refreshIntervalTime: e,
      clientStorageGetter: r,
      clientStorageSetter: n,
      clientStorage: c,
      clientStorageType: s,
      autoRefreshToken: a,
      autoSignIn: u,
      start: g,
      ...d
    }), this.storage = N({ adminSecret: i, ...d }), this.functions = $({ adminSecret: i, ...d }), this.graphql = y({ adminSecret: i, ...d }), this.auth.client.onStart(() => {
      const T = this.auth.getAccessToken();
      this.storage.setAccessToken(T), this.functions.setAccessToken(T), this.graphql.setAccessToken(T), this.auth.onAuthStateChanged((h, f) => {
        h === "SIGNED_OUT" && (this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0));
      }), this.auth.onTokenChanged((h) => {
        const f = h == null ? void 0 : h.accessToken;
        this.storage.setAccessToken(f), this.functions.setAccessToken(f), this.graphql.setAccessToken(f);
      });
    }), this._adminSecret = i, this.devTools = l;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(e) {
    this._adminSecret = e, this.storage.setAdminSecret(e);
  }
}
export {
  G as NhostClient,
  _ as NhostFunctionsClient,
  H as NhostGraphqlClient,
  C as createAuthClient,
  $ as createFunctionsClient,
  y as createGraphqlClient,
  B as createNhostClient,
  N as createStorageClient
};
//# sourceMappingURL=index.esm.js.map
