import { NhostClient as L } from "@nhost/nhost-js";
import I, { createContext as C, useRef as M, useEffect as U, useContext as w, useState as P, useMemo as x, useCallback as N } from "react";
import { useInterpret as v, useSelector as n } from "@xstate/react";
import R from "immer";
import { addSecurityKeyPromise as D, createChangeEmailMachine as V, changeEmailPromise as K, createChangePasswordMachine as F, changePasswordPromise as q, createEnableMfaMachine as _, generateQrCodePromise as Q, activateMfaPromise as $, encodeQueryParameters as j, rewriteRedirectTo as G, createResetPasswordMachine as H, resetPasswordPromise as J, createSendVerificationEmailMachine as B, sendVerificationEmailPromise as W, signInAnonymousPromise as Y, signInEmailPasswordPromise as z, signInMfaTotpPromise as X, signInEmailPasswordlessPromise as Z, signInEmailSecurityKeyPromise as b, signInSmsPasswordlessPromise as ee, signInSmsPasswordlessOtpPromise as T, signOutPromise as te, signUpEmailPasswordPromise as se, signUpEmailSecurityKeyPromise as ne } from "@nhost/core";
import oe from "jwt-decode";
import { createFileUploadMachine as re, uploadFilePromise as ce, createMultipleFilesUploadMachine as ie, uploadMultipleFilesPromise as ae } from "@nhost/hasura-storage-js";
class Ue extends L {
  constructor(t) {
    super({ ...t, start: !1 });
  }
}
const A = C({}), ke = ({
  nhost: e,
  initial: t,
  ...s
}) => {
  const a = e.auth.client.machine, h = v(a, {
    devTools: e.devTools,
    context: R(a.context, (u) => {
      var p, m;
      t && (u.user = t.user, u.refreshToken.value = (p = t.refreshToken) != null ? p : null, u.accessToken.value = (m = t.accessToken) != null ? m : null, u.accessToken.expiresAt = new Date(Date.now() + t.accessTokenExpiresIn * 1e3));
    })
  }).start(), d = M(!0);
  return U(() => {
    d.current ? d.current = !1 : t && h.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, h]), e.auth.client.interpreter = h, /* @__PURE__ */ I.createElement(A.Provider, {
    value: e
  }, s.children);
}, y = () => {
  var s;
  const t = (s = w(A).auth) == null ? void 0 : s.client.interpreter;
  if (!t)
    throw Error("No interpreter");
  return t;
}, k = () => {
  const e = y();
  return n(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, s) => t.isAuthenticated === s.isAuthenticated && t.isLoading === s.isLoading && t.connectionAttempts === s.connectionAttempts
  );
};
function Te({ children: e }) {
  const { isAuthenticated: t } = k();
  return t ? /* @__PURE__ */ I.createElement(I.Fragment, null, e) : null;
}
function Oe({ children: e }) {
  const { isAuthenticated: t } = k();
  return t ? null : /* @__PURE__ */ I.createElement(I.Fragment, null, e);
}
const ue = () => {
  const e = y();
  return n(e, (t) => t.context.accessToken.value);
}, S = () => w(A), Le = () => {
  const e = S(), [t, s] = P(null), a = !t, h = !!t, [d, u] = P(!1);
  return { add: async (m) => {
    u(!0);
    const o = await D(e.auth.client, m), { error: r } = o;
    return r && s(r), u(!1), o;
  }, isLoading: d, isSuccess: a, isError: h, error: t };
}, Ce = () => {
  const e = y(), [t, s] = P(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return U(() => e.subscribe((h) => {
    const d = h.matches({ authentication: "signedIn" });
    s(d);
  }).unsubscribe, [e]), t;
}, Me = () => {
  const e = y();
  return n(e, (t) => t.hasTag("loading"));
};
function Ne(e, t) {
  const s = x(() => typeof e == "string" ? e : void 0, [e]), a = x(() => typeof e != "string" ? e : t, [e, t]), h = S(), d = x(() => V(h.auth.client), [h]), u = v(d), p = n(u, (i) => i.matches("requesting")), m = n(u, (i) => i.context.error), o = n(u, (i) => i.matches("idle.error")), r = n(u, (i) => i.matches("idle.success"));
  return { changeEmail: N(
    async (i, g = a) => K(
      u,
      typeof i == "string" ? i : s,
      g
    ),
    [u, s, a]
  ), isLoading: p, needsEmailVerification: r, isError: o, error: m };
}
const Re = (e) => {
  const t = S(), s = x(() => F(t.auth.client), [t]), a = v(s), h = n(a, (o) => o.matches({ idle: "error" })), d = n(a, (o) => o.matches({ idle: "success" })), u = n(a, (o) => o.context.error), p = n(a, (o) => o.matches("requesting"));
  return { changePassword: (o) => q(
    a,
    typeof o == "string" ? o : e
  ), isLoading: p, isSuccess: d, isError: h, error: u };
}, De = () => {
  const e = S(), t = x(() => _(e.auth.client), [e]), s = v(t), a = n(
    s,
    (i) => i.matches({ idle: "error" }) || i.matches({ generated: { idle: "error" } })
  ), h = n(s, (i) => i.matches("generating")), d = n(s, (i) => i.matches("generated")), u = n(s, (i) => i.matches({ generated: "activating" })), p = n(s, (i) => i.matches({ generated: "activated" })), m = n(s, (i) => i.context.error), o = n(s, (i) => i.context.imageUrl || "");
  return {
    generateQrCode: () => Q(s),
    isGenerating: h,
    qrCodeDataUrl: o,
    isGenerated: d,
    activateMfa: (i) => $(s, i),
    isActivating: u,
    isActivated: p,
    isError: a,
    error: m
  };
}, le = () => {
  const e = ue();
  return e ? oe(e) : null;
}, de = (e) => {
  const t = S(), s = (f) => {
    e.send({
      type: "ADD",
      file: f.file,
      bucketId: f.bucketId || i
    });
  }, a = (f) => ce(t, e, {
    file: f.file,
    bucketId: f.bucketId || i,
    id: l,
    name: g
  }), h = () => {
    e.send("CANCEL");
  }, d = () => {
    e.send("DESTROY");
  }, u = n(e, (f) => f.matches("uploading")), p = n(e, (f) => f.matches("uploaded")), m = n(e, (f) => f.matches("error")), o = n(e, (f) => f.context.error || null), r = n(e, (f) => f.context.progress), l = n(e, (f) => f.context.id), i = n(e, (f) => f.context.bucketId), g = n(e, (f) => {
    var c;
    return (c = f.context.file) == null ? void 0 : c.name;
  });
  return {
    add: s,
    upload: a,
    cancel: h,
    destroy: d,
    isUploaded: p,
    isUploading: u,
    isError: m,
    error: o,
    progress: r,
    id: l,
    bucketId: i,
    name: g
  };
}, Ve = () => {
  const e = v(re);
  return de(e);
}, me = () => {
  const e = le();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, Ke = (e) => {
  const t = me();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, Fe = () => {
  const e = S(), [t, s] = P([]), a = v(ie, {}, (g) => {
    g.event.type === "UPLOAD_ERROR" ? s(g.context.files.filter((f) => {
      var c;
      return (c = f.getSnapshot()) == null ? void 0 : c.context.error;
    })) : (g.matches("uploaded") || g.event.type === "CLEAR") && t.length > 0 && s([]);
  }), h = (g) => {
    a.send({ type: "ADD", ...g });
  }, d = (g) => ae(e, a, g), u = () => {
    a.send("CANCEL");
  }, p = () => {
    a.send("CLEAR");
  }, m = n(a, (g) => g.matches("uploading")), o = n(a, (g) => g.matches("uploaded")), r = n(a, (g) => g.matches("error")), l = n(a, (g) => g.context.progress), i = n(a, (g) => g.context.files);
  return {
    upload: d,
    add: h,
    clear: p,
    cancel: u,
    progress: l,
    isUploaded: o,
    isUploading: m,
    files: i,
    isError: r,
    errors: t
  };
}, he = () => {
  const e = y();
  return n(
    e,
    (t) => t.context.user,
    (t, s) => (t && JSON.stringify(t)) === (s && JSON.stringify(s))
  );
}, qe = () => {
  const { isLoading: e, isAuthenticated: t } = k(), s = he();
  return x(() => ({ isLoading: e, isAuthenticated: t, user: s }), [e, t, s]);
}, _e = () => w(A).auth.client.backendUrl.replace("/v1/auth", ""), Qe = (e) => {
  const [t, s] = P(!0);
  U(() => {
    s(!1);
  }, []);
  const a = w(A);
  return new Proxy({}, {
    get(h, d) {
      return j(
        `${a.auth.client.backendUrl}/signin/provider/${d}`,
        G(t ? void 0 : a.auth.client.clientUrl, e)
      );
    }
  });
}, $e = (e, t) => {
  const s = typeof e == "string" ? e : void 0, a = typeof e != "string" ? e : t, h = S(), d = x(() => H(h.auth.client), [h]), u = v(d), p = n(u, (i) => i.matches("requesting")), m = n(u, (i) => i.context.error), o = n(u, (i) => i.matches("idle.error")), r = n(u, (i) => i.matches("idle.success"));
  return { resetPassword: (i, g = a) => J(
    u,
    typeof i == "string" ? i : s,
    g
  ), isLoading: p, isSent: r, isError: o, error: m };
}, je = (e, t) => {
  const s = typeof e == "string" ? e : void 0, a = typeof e != "string" ? e : t, h = S(), d = x(() => B(h.auth.client), [h]), u = v(d), p = n(u, (i) => i.matches({ idle: "error" })), m = n(u, (i) => i.matches({ idle: "success" })), o = n(u, (i) => i.context.error), r = n(u, (i) => i.matches("requesting"));
  return { sendEmail: (i, g = a) => W(
    u,
    typeof i == "string" ? i : s,
    g
  ), isLoading: r, isSent: m, isError: p, error: o };
}, Ge = () => {
  const e = y(), t = () => Y(e), s = n(
    e,
    (m) => m.context.errors.authentication || null,
    (m, o) => (m == null ? void 0 : m.error) === (o == null ? void 0 : o.error)
  ), a = n(
    e,
    (m) => m.matches({ authentication: { authenticating: "anonymous" } })
  ), h = n(
    e,
    (m) => m.matches({
      authentication: "signedIn"
    })
  ), d = n(
    e,
    (m) => m.matches({ authentication: { signedOut: "failed" } })
  ), u = n(
    e,
    (m) => m.context.user,
    (m, o) => (m == null ? void 0 : m.id) === (o == null ? void 0 : o.id)
  );
  return { accessToken: n(e, (m) => m.context.accessToken.value), error: s, isError: d, isLoading: a, isSuccess: h, signInAnonymous: t, user: u };
}, He = (e, t, s) => {
  const a = y(), h = (c, E) => z(
    a,
    typeof c == "string" ? c : e,
    typeof E == "string" ? E : t
  ), d = (c) => X(a, typeof c == "string" ? c : s), u = n(
    a,
    (c) => c.context.user,
    (c, E) => (c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)
  ), p = n(a, (c) => c.context.accessToken.value), m = n(
    a,
    (c) => c.context.errors.authentication || null,
    (c, E) => (c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)
  ), o = n(
    a,
    (c) => c.matches({
      authentication: "signedIn"
    })
  ), r = n(
    a,
    (c) => c.matches({ authentication: { authenticating: "password" } }),
    (c, E) => c === E
  ), l = n(
    a,
    (c) => c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (c, E) => c === E
  ), i = n(
    a,
    (c) => c.matches({ authentication: { signedOut: "needsMfa" } }),
    (c, E) => c === E
  ), g = n(
    a,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, E) => c === E
  ), f = n(a, (c) => c.context.mfa);
  return {
    accessToken: p,
    error: m,
    isError: g,
    isLoading: r,
    isSuccess: o,
    needsEmailVerification: l,
    needsMfaOtp: i,
    mfa: f,
    sendMfaOtp: d,
    signInEmailPassword: h,
    user: u
  };
};
function Je(e, t) {
  const s = typeof e == "string" ? e : void 0, a = typeof e == "string" ? t : e, h = y(), d = (r, l = a) => Z(
    h,
    typeof r == "string" ? r : s,
    l
  ), u = n(
    h,
    (r) => r.context.errors.registration || null,
    (r, l) => (r == null ? void 0 : r.error) === (l == null ? void 0 : l.error)
  ), p = n(h, (r) => r.matches("registration.passwordlessEmail")), m = n(
    h,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), o = n(h, (r) => r.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: d, isLoading: p, isSuccess: m, isError: o, error: u };
}
const Be = () => {
  const e = y(), t = (o) => b(e, o), s = n(
    e,
    (o) => o.context.user,
    (o, r) => (o == null ? void 0 : o.id) === (r == null ? void 0 : r.id)
  ), a = n(e, (o) => o.context.accessToken.value), h = n(
    e,
    (o) => o.context.errors.authentication || null,
    (o, r) => (o == null ? void 0 : o.error) === (r == null ? void 0 : r.error)
  ), d = n(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), u = n(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, r) => o === r
  ), p = n(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, r) => o === r
  ), m = n(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, r) => o === r
  );
  return {
    accessToken: a,
    error: h,
    isError: m,
    isLoading: u,
    isSuccess: d,
    needsEmailVerification: p,
    signInEmailSecurityKey: t,
    user: s
  };
};
function We(e) {
  const t = y(), [s, a] = P(""), h = (l, i = e) => (a(l), ee(t, l, i)), d = async (...l) => {
    if (l.length === 2) {
      const [g, f] = l;
      return T(t, g, f);
    }
    const [i] = l;
    return T(t, s, i);
  }, u = n(
    t,
    (l) => l.context.errors.registration || null,
    (l, i) => (l == null ? void 0 : l.error) === (i == null ? void 0 : i.error)
  ), p = n(
    t,
    (l) => l.matches("registration.passwordlessSms") || l.matches("registration.passwordlessSmsOtp")
  ), m = n(t, (l) => l.matches("authentication.signedIn")), o = n(
    t,
    (l) => l.matches("registration.incomplete.needsOtp")
  ), r = n(t, (l) => l.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: h, sendOtp: d, isLoading: p, isSuccess: m, needsOtp: o, isError: r, error: u };
}
const Ye = (e = !1) => {
  const t = y(), s = (d) => te(t, typeof d == "boolean" ? d : e), a = n(
    t,
    (d) => d.matches({ authentication: { signedOut: "success" } }),
    (d, u) => d === u
  ), h = n(
    t,
    (d) => d.context.errors.signout || null,
    (d, u) => (d == null ? void 0 : d.error) === (u == null ? void 0 : u.error)
  );
  return { signOut: s, isSuccess: a, error: h };
}, ze = (e, t, s) => {
  const a = typeof e == "string" ? e : void 0, h = typeof t == "string" ? t : void 0, d = s || (typeof e != "string" ? e : void 0), u = y(), p = n(u, (c) => !!c.context.errors.registration), m = n(
    u,
    (c) => c.context.errors.registration || null,
    (c, E) => (c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)
  ), o = n(u, (c) => c.matches("registration.emailPassword")), r = n(
    u,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), l = n(
    u,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), i = (c, E = h, O = d) => se(
    u,
    typeof c == "string" ? c : a,
    E,
    O
  ), g = n(
    u,
    (c) => c.context.user,
    (c, E) => (c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)
  );
  return {
    accessToken: n(u, (c) => c.context.accessToken.value),
    error: m,
    isError: p,
    isLoading: o,
    isSuccess: l,
    needsEmailVerification: r,
    signUpEmailPassword: i,
    user: g
  };
}, Xe = (e) => {
  const t = y(), s = n(t, (r) => !!r.context.errors.registration), a = n(
    t,
    (r) => r.context.errors.registration || null,
    (r, l) => (r == null ? void 0 : r.error) === (l == null ? void 0 : l.error)
  ), h = n(t, (r) => r.matches("registration.securityKey")), d = n(
    t,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), u = n(
    t,
    (r) => r.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), p = (r, l = e) => ne(t, r, l), m = n(
    t,
    (r) => r.context.user,
    (r, l) => (r == null ? void 0 : r.id) === (l == null ? void 0 : l.id)
  );
  return {
    accessToken: n(t, (r) => r.context.accessToken.value),
    error: a,
    isError: s,
    isLoading: h,
    isSuccess: u,
    needsEmailVerification: d,
    signUpEmailSecurityKey: p,
    user: m
  };
}, ge = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.avatarUrl;
    },
    (t, s) => t === s
  );
}, Ze = ge, pe = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.defaultRole;
    },
    (t, s) => t === s
  );
}, be = pe, fe = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.displayName;
    },
    (t, s) => t === s
  );
}, et = fe, Ee = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.email;
    },
    (t, s) => t === s
  );
}, tt = Ee, st = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.id;
    },
    (t, s) => t === s
  );
}, ye = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.isAnonymous;
    },
    (t, s) => t === s
  );
}, nt = ye, ot = () => {
  const e = y();
  return n(
    e,
    (t) => {
      var s;
      return (s = t.context.user) == null ? void 0 : s.locale;
    },
    (t, s) => t === s
  );
}, rt = () => {
  const e = y();
  return n(e, (t) => {
    var s;
    return t.matches("authentication.signedIn") ? ((s = t.context.user) == null ? void 0 : s.roles) || [] : [];
  });
};
export {
  Ue as NhostClient,
  A as NhostReactContext,
  ke as NhostReactProvider,
  Te as SignedIn,
  Oe as SignedOut,
  ue as useAccessToken,
  Le as useAddSecurityKey,
  y as useAuthInterpreter,
  Me as useAuthLoading,
  Ce as useAuthenticated,
  k as useAuthenticationStatus,
  Ze as useAvatarUrl,
  Ne as useChangeEmail,
  Re as useChangePassword,
  De as useConfigMfa,
  le as useDecodedAccessToken,
  be as useDefaultRole,
  et as useDisplayName,
  tt as useEmail,
  Ve as useFileUpload,
  de as useFileUploadItem,
  Ke as useHasuraClaim,
  me as useHasuraClaims,
  nt as useIsAnonymous,
  Fe as useMultipleFilesUpload,
  qe as useNhostAuth,
  _e as useNhostBackendUrl,
  S as useNhostClient,
  Qe as useProviderLink,
  $e as useResetPassword,
  je as useSendVerificationEmail,
  Ge as useSignInAnonymous,
  He as useSignInEmailPassword,
  Je as useSignInEmailPasswordless,
  Be as useSignInEmailSecurityKey,
  We as useSignInSmsPasswordless,
  Ye as useSignOut,
  ze as useSignUpEmailPassword,
  Xe as useSignUpEmailSecurityKeyEmail,
  ge as useUserAvatarUrl,
  he as useUserData,
  pe as useUserDefaultRole,
  fe as useUserDisplayName,
  Ee as useUserEmail,
  st as useUserId,
  ye as useUserIsAnonymous,
  ot as useUserLocale,
  rt as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
