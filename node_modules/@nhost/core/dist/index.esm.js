var re = Object.defineProperty;
var se = (r, e, t) => e in r ? re(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var A = (r, e, t) => (se(r, typeof e != "symbol" ? e + "" : e, t), t);
import { createMachine as b, assign as h, send as w, interpret as te } from "xstate";
import ne from "axios";
import L from "js-cookie";
function ie(r) {
  return new TextEncoder().encode(r);
}
function _(r) {
  const e = new Uint8Array(r);
  let t = "";
  for (const n of e)
    t += String.fromCharCode(n);
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function W(r) {
  const e = r.replace(/-/g, "+").replace(/_/g, "/"), t = (4 - e.length % 4) % 4, s = e.padEnd(e.length + t, "="), n = atob(s), i = new ArrayBuffer(n.length), u = new Uint8Array(i);
  for (let d = 0; d < n.length; d++)
    u[d] = n.charCodeAt(d);
  return i;
}
function z() {
  return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function H(r) {
  const { id: e } = r;
  return {
    ...r,
    id: W(e),
    transports: r.transports
  };
}
function Q(r) {
  return r === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(r);
}
class g extends Error {
  constructor(e, t = "WebAuthnError") {
    super(e), this.name = t;
  }
}
function oe({ error: r, options: e }) {
  var t, s;
  const { publicKey: n } = e;
  if (!n)
    throw Error("options was missing required publicKey property");
  if (r.name === "AbortError") {
    if (e.signal === new AbortController().signal)
      return new g("Registration ceremony was sent an abort signal", "AbortError");
  } else if (r.name === "ConstraintError") {
    if (((t = n.authenticatorSelection) === null || t === void 0 ? void 0 : t.requireResidentKey) === !0)
      return new g("Discoverable credentials were required but no available authenticator supported it", "ConstraintError");
    if (((s = n.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required")
      return new g("User verification was required but no available authenticator supported it", "ConstraintError");
  } else {
    if (r.name === "InvalidStateError")
      return new g("The authenticator was previously registered", "InvalidStateError");
    if (r.name === "NotAllowedError")
      return new g("User clicked cancel, or the registration ceremony timed out", "NotAllowedError");
    if (r.name === "NotSupportedError")
      return n.pubKeyCredParams.filter((u) => u.type === "public-key").length === 0 ? new g('No entry in pubKeyCredParams was of type "public-key"', "NotSupportedError") : new g("No available authenticator supported any of the specified pubKeyCredParams algorithms", "NotSupportedError");
    if (r.name === "SecurityError") {
      const i = window.location.hostname;
      if (Q(i)) {
        if (n.rp.id !== i)
          return new g(`The RP ID "${n.rp.id}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (r.name === "TypeError") {
      if (n.user.id.byteLength < 1 || n.user.id.byteLength > 64)
        return new g("User ID was not between 1 and 64 characters", "TypeError");
    } else if (r.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new credential", "UnknownError");
  }
  return r;
}
class ae {
  createNewAbortSignal() {
    return this.controller && this.controller.abort(), this.controller = new AbortController(), this.controller.signal;
  }
  reset() {
    this.controller = void 0;
  }
}
const M = new ae();
async function X(r) {
  if (!z())
    throw new Error("WebAuthn is not supported in this browser");
  const t = { publicKey: {
    ...r,
    challenge: W(r.challenge),
    user: {
      ...r.user,
      id: ie(r.user.id)
    },
    excludeCredentials: r.excludeCredentials.map(H)
  } };
  t.signal = M.createNewAbortSignal();
  let s;
  try {
    s = await navigator.credentials.create(t);
  } catch (p) {
    throw oe({ error: p, options: t });
  } finally {
    M.reset();
  }
  if (!s)
    throw new Error("Registration was not completed");
  const { id: n, rawId: i, response: u, type: d } = s, E = {
    id: n,
    rawId: _(i),
    response: {
      attestationObject: _(u.attestationObject),
      clientDataJSON: _(u.clientDataJSON)
    },
    type: d,
    clientExtensionResults: s.getClientExtensionResults(),
    authenticatorAttachment: s.authenticatorAttachment
  };
  return typeof u.getTransports == "function" && (E.transports = u.getTransports()), E;
}
function ce(r) {
  return new TextDecoder("utf-8").decode(r);
}
async function ue() {
  if (navigator.credentials.conditionalMediationSupported)
    return !0;
  const r = window.PublicKeyCredential;
  return r.isConditionalMediationAvailable !== void 0 && r.isConditionalMediationAvailable();
}
function le({ error: r, options: e }) {
  var t;
  const { publicKey: s } = e;
  if (!s)
    throw Error("options was missing required publicKey property");
  if (r.name === "AbortError") {
    if (e.signal === new AbortController().signal)
      return new g("Authentication ceremony was sent an abort signal", "AbortError");
  } else {
    if (r.name === "NotAllowedError")
      return !((t = s.allowCredentials) === null || t === void 0) && t.length ? new g("No available authenticator recognized any of the allowed credentials", "NotAllowedError") : new g("User clicked cancel, or the authentication ceremony timed out", "NotAllowedError");
    if (r.name === "SecurityError") {
      const n = window.location.hostname;
      if (Q(n)) {
        if (s.rpId !== n)
          return new g(`The RP ID "${s.rpId}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (r.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new assertion signature", "UnknownError");
  }
  return r;
}
async function de(r, e = !1) {
  var t, s;
  if (!z())
    throw new Error("WebAuthn is not supported in this browser");
  let n;
  ((t = r.allowCredentials) === null || t === void 0 ? void 0 : t.length) !== 0 && (n = (s = r.allowCredentials) === null || s === void 0 ? void 0 : s.map(H));
  const i = {
    ...r,
    challenge: W(r.challenge),
    allowCredentials: n
  }, u = {};
  if (e) {
    if (!await ue())
      throw Error("Browser does not support WebAuthn autofill");
    if (document.querySelectorAll("input[autocomplete*='webauthn']").length < 1)
      throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');
    u.mediation = "conditional", i.allowCredentials = [];
  }
  u.publicKey = i, u.signal = M.createNewAbortSignal();
  let d;
  try {
    d = await navigator.credentials.get(u);
  } catch (o) {
    throw le({ error: o, options: u });
  } finally {
    M.reset();
  }
  if (!d)
    throw new Error("Authentication was not completed");
  const { id: E, rawId: p, response: m, type: S } = d;
  let f;
  return m.userHandle && (f = ce(m.userHandle)), {
    id: E,
    rawId: _(p),
    response: {
      authenticatorData: _(m.authenticatorData),
      clientDataJSON: _(m.clientDataJSON),
      signature: _(m.signature),
      userHandle: f
    },
    type: S,
    clientExtensionResults: d.getClientExtensionResults(),
    authenticatorAttachment: d.authenticatorAttachment
  };
}
const C = "nhostRefreshToken", N = "nhostRefreshTokenExpiresAt", fe = 3, he = 300, me = 5, Z = 0, J = 1, y = 10, P = 20;
class D extends Error {
  constructor(t) {
    super(t.message);
    A(this, "error");
    Error.captureStackTrace(this, this.constructor), t instanceof Error ? (this.name = t.name, this.error = {
      error: t.name,
      status: J,
      message: t.message
    }) : (this.name = t.error, this.error = t);
  }
}
const R = {
  status: y,
  error: "invalid-email",
  message: "Email is incorrectly formatted"
}, Ee = {
  status: y,
  error: "invalid-mfa-type",
  message: "MFA type is invalid"
}, ge = {
  status: y,
  error: "invalid-mfa-code",
  message: "MFA code is invalid"
}, G = {
  status: y,
  error: "invalid-password",
  message: "Password is incorrectly formatted"
}, Y = {
  status: y,
  error: "invalid-phone-number",
  message: "Phone number is incorrectly formatted"
}, pe = {
  status: y,
  error: "invalid-mfa-ticket",
  message: "MFA ticket is invalid"
}, we = {
  status: y,
  error: "no-mfa-ticket",
  message: "No MFA ticket has been provided"
}, xe = {
  status: y,
  error: "no-refresh-token",
  message: "No refresh token has been provided"
}, De = {
  status: P,
  error: "refresher-already-running",
  message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
}, I = {
  status: P,
  error: "already-signed-in",
  message: "User is already signed in"
}, Te = {
  status: P,
  error: "unauthenticated-user",
  message: "User is not authenticated"
}, Ue = {
  status: P,
  error: "user-not-anonymous",
  message: "User is not anonymous"
}, Me = {
  status: P,
  error: "unverified-user",
  message: "Email needs verification"
}, Ve = {
  status: y,
  error: "invalid-refresh-token",
  message: "Invalid or expired refresh token"
}, Ke = {
  status: J,
  error: "invalid-sign-in-method",
  message: "Invalid sign-in method"
}, O = (r) => {
  const e = ne.create({ baseURL: r });
  return e.interceptors.response.use(
    (t) => t,
    (t) => {
      var s, n, i, u, d, E, p, m, S, f, o, a;
      return Promise.reject({
        error: {
          message: (d = (u = (i = (n = (s = t.response) == null ? void 0 : s.data) == null ? void 0 : n.message) != null ? i : t.message) != null ? u : t.request.responseText) != null ? d : JSON.stringify(t),
          status: (f = (S = (E = t.response) == null ? void 0 : E.status) != null ? S : (m = (p = t.response) == null ? void 0 : p.data) == null ? void 0 : m.statusCode) != null ? f : Z,
          error: ((a = (o = t.response) == null ? void 0 : o.data) == null ? void 0 : a.error) || t.request.statusText || "network"
        }
      });
    }
  ), e;
}, V = typeof window < "u", U = /* @__PURE__ */ new Map(), ye = (r) => {
  var e;
  return V && typeof localStorage < "u" ? localStorage.getItem(r) : (e = U.get(r)) != null ? e : null;
}, Se = (r, e) => {
  V && typeof localStorage < "u" ? e ? localStorage.setItem(r, e) : localStorage.removeItem(r) : e ? U.set(r, e) : U.has(r) && U.delete(r);
}, ve = (r, e) => {
  if (r === "localStorage" || r === "web")
    return ye;
  if (r === "cookie")
    return (t) => {
      var s;
      return V && (s = L.get(t)) != null ? s : null;
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${r}' but no clientStorage has been given`
    );
  if (r === "react-native")
    return (t) => {
      var s;
      return (s = e.getItem) == null ? void 0 : s.call(e, t);
    };
  if (r === "capacitor")
    return (t) => {
      var s;
      return (s = e.get) == null ? void 0 : s.call(e, { key: t });
    };
  if (r === "expo-secure-storage")
    return (t) => {
      var s;
      return (s = e.getItemAsync) == null ? void 0 : s.call(e, t);
    };
  if (r === "custom") {
    if (e.getItem && e.removeItem)
      return e.getItem;
    if (e.getItemAsync)
      return e.getItemAsync;
    throw Error(
      `clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`
    );
  }
  throw Error(`Unknown storage type: ${r}`);
}, Ie = (r, e) => {
  if (r === "localStorage" || r === "web")
    return Se;
  if (r === "cookie")
    return (t, s) => {
      V && (s ? L.set(t, s, { expires: 30, sameSite: "lax", httpOnly: !1 }) : L.remove(t));
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${r}' but no clienStorage has been given`
    );
  if (r === "react-native")
    return (t, s) => {
      var n, i;
      return s ? (n = e.setItem) == null ? void 0 : n.call(e, t, s) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
    };
  if (r === "capacitor")
    return (t, s) => {
      var n, i;
      return s ? (n = e.set) == null ? void 0 : n.call(e, { key: t, value: s }) : (i = e.remove) == null ? void 0 : i.call(e, { key: t });
    };
  if (r === "expo-secure-storage")
    return async (t, s) => {
      var n, i;
      return s ? (n = e.setItemAsync) == null ? void 0 : n.call(e, t, s) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, t);
    };
  if (r === "custom") {
    if (!e.removeItem)
      throw Error(
        "clientStorageType is set to 'custom' but clientStorage is missing a removeItem property"
      );
    if (e.setItem)
      return (t, s) => {
        var n, i;
        return s ? (n = e.setItem) == null ? void 0 : n.call(e, t, s) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
      };
    if (e.setItemAsync)
      return async (t, s) => {
        var n, i;
        return s ? (n = e.setItemAsync) == null ? void 0 : n.call(e, t, s) : (i = e.removeItem) == null ? void 0 : i.call(e, t);
      };
    throw Error(
      "clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property"
    );
  }
  throw Error(`Unknown storage type: ${r}`);
}, Ae = (r, e) => {
  const t = e && Object.entries(e).map(([s, n]) => {
    const i = Array.isArray(n) ? n.join(",") : typeof n == "object" ? JSON.stringify(n) : n;
    return `${s}=${encodeURIComponent(i)}`;
  }).join("&");
  return t ? `${r}?${t}` : r;
}, v = (r, e) => {
  if (!(e != null && e.redirectTo))
    return e;
  const { redirectTo: t, ...s } = e;
  if (!r)
    return t.startsWith("/") ? s : e;
  const n = new URL(r), i = Object.fromEntries(new URLSearchParams(n.search)), u = new URL(t.startsWith("/") ? n.origin + t : t), d = new URLSearchParams(u.search);
  let E = Object.fromEntries(d);
  t.startsWith("/") && (E = { ...i, ...E });
  let p = n.pathname;
  return u.pathname.length > 1 && (p += u.pathname.slice(1)), {
    ...s,
    redirectTo: Ae(u.origin + p, E)
  };
};
function x(r, e) {
  var n;
  if (!e) {
    if (typeof window > "u")
      return;
    e = ((n = window.location) == null ? void 0 : n.href) || "";
  }
  r = r.replace(/[\[\]]/g, "\\$&");
  const t = new RegExp("[?&#]" + r + "(=([^&#]*)|&|#|$)"), s = t.exec(e);
  return s ? s[2] ? decodeURIComponent(s[2].replace(/\+/g, " ")) : "" : null;
}
function j(r) {
  var t;
  if (typeof window > "u")
    return;
  const e = window == null ? void 0 : window.location;
  if (!!e && e) {
    const s = new URLSearchParams(e.search), n = new URLSearchParams((t = e.hash) == null ? void 0 : t.slice(1));
    s.delete(r), n.delete(r);
    let i = window.location.pathname;
    Array.from(s).length && (i += `?${s.toString()}`), Array.from(n).length && (i += `#${n.toString()}`), window.history.pushState({}, "", i);
  }
}
const k = (r) => !!r && typeof r == "string" && !!String(r).toLowerCase().match(
  /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
), q = (r) => !!r && typeof r == "string" && r.length >= fe, B = (r) => !!r && typeof r == "string", Re = (r) => r && typeof r == "string" && r.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i), K = {
  user: null,
  mfa: null,
  accessToken: {
    value: null,
    expiresAt: null
  },
  refreshTimer: {
    startedAt: null,
    attempts: 0,
    lastAttempt: null
  },
  refreshToken: {
    value: null
  },
  importTokenAttempts: 0,
  errors: {}
}, Le = ({ backendUrl: r, clientUrl: e, interpreter: t }) => {
  const s = O(r);
  return b(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      predictableActionArguments: !0,
      id: "changeEmail",
      initial: "idle",
      context: { error: null },
      states: {
        idle: {
          on: {
            REQUEST: [
              {
                cond: "invalidEmail",
                actions: "saveInvalidEmailError",
                target: ".error"
              },
              {
                target: "requesting"
              }
            ]
          },
          initial: "initial",
          states: {
            initial: {},
            success: {},
            error: {}
          }
        },
        requesting: {
          invoke: {
            src: "requestChange",
            id: "requestChange",
            onDone: { target: "idle.success", actions: "reportSuccess" },
            onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
          }
        }
      }
    },
    {
      actions: {
        saveInvalidEmailError: h({ error: (n) => R }),
        saveRequestError: h({
          error: (n, { data: { error: i } }) => i
        }),
        reportError: w((n) => ({ type: "ERROR", error: n.error })),
        reportSuccess: w("SUCCESS")
      },
      guards: {
        invalidEmail: (n, { email: i }) => !k(i)
      },
      services: {
        requestChange: async (n, { email: i, options: u }) => (await s.post(
          "/user/email/change",
          {
            newEmail: i,
            options: v(e, u)
          },
          {
            headers: {
              authorization: `Bearer ${t == null ? void 0 : t.getSnapshot().context.accessToken.value}`
            }
          }
        )).data
      }
    }
  );
}, Ge = ({ backendUrl: r, interpreter: e }) => {
  const t = O(r);
  return b(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      predictableActionArguments: !0,
      id: "changePassword",
      initial: "idle",
      context: { error: null },
      states: {
        idle: {
          on: {
            REQUEST: [
              {
                cond: "invalidPassword",
                actions: "saveInvalidPasswordError",
                target: ".error"
              },
              {
                target: "requesting"
              }
            ]
          },
          initial: "initial",
          states: {
            initial: {},
            success: {},
            error: {}
          }
        },
        requesting: {
          invoke: {
            src: "requestChange",
            id: "requestChange",
            onDone: { target: "idle.success", actions: "reportSuccess" },
            onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
          }
        }
      }
    },
    {
      actions: {
        saveInvalidPasswordError: h({ error: (s) => G }),
        saveRequestError: h({
          error: (s, { data: { error: n } }) => n
        }),
        reportError: w((s) => ({ type: "ERROR", error: s.error })),
        reportSuccess: w("SUCCESS")
      },
      guards: {
        invalidPassword: (s, { password: n }) => !q(n)
      },
      services: {
        requestChange: (s, { password: n, ticket: i }) => t.post(
          "/user/password",
          { newPassword: n, ticket: i },
          {
            headers: {
              authorization: `Bearer ${e == null ? void 0 : e.getSnapshot().context.accessToken.value}`
            }
          }
        )
      }
    }
  );
}, qe = ({ backendUrl: r, interpreter: e }) => {
  const t = O(r);
  return b(
    {
      schema: {
        context: {},
        events: {}
      },
      tsTypes: {},
      predictableActionArguments: !0,
      id: "enableMfa",
      initial: "idle",
      context: { error: null, imageUrl: null, secret: null },
      states: {
        idle: {
          initial: "initial",
          on: {
            GENERATE: "generating"
          },
          states: {
            initial: {},
            error: {}
          }
        },
        generating: {
          invoke: {
            src: "generate",
            id: "generate",
            onDone: { target: "generated", actions: ["reportGeneratedSuccess", "saveGeneration"] },
            onError: { actions: ["saveError", "reportGeneratedError"], target: "idle.error" }
          }
        },
        generated: {
          initial: "idle",
          states: {
            idle: {
              initial: "idle",
              on: {
                ACTIVATE: [
                  {
                    cond: "invalidMfaType",
                    actions: "saveInvalidMfaTypeError",
                    target: ".error"
                  },
                  {
                    cond: "invalidMfaCode",
                    actions: "saveInvalidMfaCodeError",
                    target: ".error"
                  },
                  {
                    target: "activating"
                  }
                ]
              },
              states: { idle: {}, error: {} }
            },
            activating: {
              invoke: {
                src: "activate",
                id: "activate",
                onDone: { target: "activated", actions: "reportSuccess" },
                onError: { actions: ["saveError", "reportError"], target: "idle.error" }
              }
            },
            activated: { type: "final" }
          }
        }
      }
    },
    {
      actions: {
        saveInvalidMfaTypeError: h({ error: (s) => Ee }),
        saveInvalidMfaCodeError: h({ error: (s) => ge }),
        saveError: h({
          error: (s, { data: { error: n } }) => n
        }),
        saveGeneration: h({
          imageUrl: (s, { data: { imageUrl: n } }) => n,
          secret: (s, { data: { totpSecret: n } }) => n
        }),
        reportError: w((s) => ({ type: "ERROR", error: s.error })),
        reportSuccess: w("SUCCESS"),
        reportGeneratedSuccess: w("GENERATED"),
        reportGeneratedError: w((s) => ({ type: "GENERATED_ERROR", error: s.error }))
      },
      guards: {
        invalidMfaCode: (s, { code: n }) => !n,
        invalidMfaType: (s, { activeMfaType: n }) => !n || n !== "totp"
      },
      services: {
        generate: async (s) => {
          const { data: n } = await t.get("/mfa/totp/generate", {
            headers: {
              authorization: `Bearer ${e == null ? void 0 : e.getSnapshot().context.accessToken.value}`
            }
          });
          return n;
        },
        activate: (s, { code: n, activeMfaType: i }) => t.post(
          "/user/mfa",
          {
            code: n,
            activeMfaType: i
          },
          {
            headers: {
              authorization: `Bearer ${e == null ? void 0 : e.getSnapshot().context.accessToken.value}`
            }
          }
        )
      }
    }
  );
}, We = ({ backendUrl: r, clientUrl: e }) => {
  const t = O(r);
  return b(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      predictableActionArguments: !0,
      id: "changePassword",
      initial: "idle",
      context: { error: null },
      states: {
        idle: {
          on: {
            REQUEST: [
              {
                cond: "invalidEmail",
                actions: "saveInvalidEmailError",
                target: ".error"
              },
              {
                target: "requesting"
              }
            ]
          },
          initial: "initial",
          states: {
            initial: {},
            success: {},
            error: {}
          }
        },
        requesting: {
          invoke: {
            src: "requestChange",
            id: "requestChange",
            onDone: { target: "idle.success", actions: "reportSuccess" },
            onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
          }
        }
      }
    },
    {
      actions: {
        saveInvalidEmailError: h({ error: (s) => R }),
        saveRequestError: h({
          error: (s, { data: { error: n } }) => n
        }),
        reportError: w((s) => ({ type: "ERROR", error: s.error })),
        reportSuccess: w("SUCCESS")
      },
      guards: {
        invalidEmail: (s, { email: n }) => !k(n)
      },
      services: {
        requestChange: (s, { email: n, options: i }) => t.post("/user/password/reset", {
          email: n,
          options: v(e, i)
        })
      }
    }
  );
}, $e = ({ backendUrl: r, clientUrl: e }) => {
  const t = O(r);
  return b(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      predictableActionArguments: !0,
      id: "sendVerificationEmail",
      initial: "idle",
      context: { error: null },
      states: {
        idle: {
          on: {
            REQUEST: [
              {
                cond: "invalidEmail",
                actions: "saveInvalidEmailError",
                target: ".error"
              },
              {
                target: "requesting"
              }
            ]
          },
          initial: "initial",
          states: {
            initial: {},
            success: {},
            error: {}
          }
        },
        requesting: {
          invoke: {
            src: "request",
            id: "request",
            onDone: { target: "idle.success", actions: "reportSuccess" },
            onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
          }
        }
      }
    },
    {
      actions: {
        saveInvalidEmailError: h({ error: (s) => R }),
        saveRequestError: h({
          error: (s, { data: { error: n } }) => n
        }),
        reportError: w((s) => ({ type: "ERROR", error: s.error })),
        reportSuccess: w("SUCCESS")
      },
      guards: {
        invalidEmail: (s, { email: n }) => !k(n)
      },
      services: {
        request: async (s, { email: n, options: i }) => (await t.post(
          "/user/email/send-verification-email",
          {
            email: n,
            options: v(e, i)
          }
        )).data
      }
    }
  );
}, ke = ({
  backendUrl: r,
  clientUrl: e,
  clientStorageGetter: t,
  clientStorageSetter: s,
  clientStorageType: n = "web",
  clientStorage: i,
  refreshIntervalTime: u,
  autoRefreshToken: d = !0,
  autoSignIn: E = !0
}) => {
  const p = t || ve(n, i), m = s || Ie(n, i), S = O(r), f = async (o, a, c) => (await S.post(o, a, c)).data;
  return b(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      context: K,
      predictableActionArguments: !0,
      id: "nhost",
      type: "parallel",
      states: {
        authentication: {
          initial: "starting",
          on: {
            SESSION_UPDATE: [
              {
                cond: "hasSession",
                actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                target: ".signedIn"
              }
            ]
          },
          states: {
            starting: {
              tags: ["loading"],
              always: { cond: "isSignedIn", target: "signedIn" },
              invoke: {
                id: "importRefreshToken",
                src: "importRefreshToken",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "signedIn"
                  },
                  {
                    target: "signedOut"
                  }
                ],
                onError: [
                  {
                    cond: "shouldRetryImportToken",
                    actions: "incrementTokenImportAttempts",
                    target: "retryTokenImport"
                  },
                  { actions: ["saveAuthenticationError"], target: "signedOut" }
                ]
              }
            },
            retryTokenImport: {
              tags: ["loading"],
              after: {
                RETRY_IMPORT_TOKEN_DELAY: "starting"
              }
            },
            signedOut: {
              initial: "noErrors",
              entry: "reportSignedOut",
              states: {
                noErrors: {},
                success: {},
                needsSmsOtp: {},
                needsMfa: {},
                failed: {},
                signingOut: {
                  entry: ["clearContextExceptRefreshToken"],
                  exit: ["destroyRefreshToken", "reportTokenChanged"],
                  invoke: {
                    src: "signout",
                    id: "signingOut",
                    onDone: {
                      target: "success"
                    },
                    onError: {
                      target: "failed",
                      actions: ["saveAuthenticationError"]
                    }
                  }
                }
              },
              on: {
                SIGNIN_PASSWORD: "authenticating.password",
                SIGNIN_ANONYMOUS: "authenticating.anonymous",
                SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                SIGNIN_MFA_TOTP: "authenticating.mfa.totp"
              }
            },
            authenticating: {
              entry: "resetErrors",
              states: {
                password: {
                  invoke: {
                    src: "signInPassword",
                    id: "authenticateUserWithPassword",
                    onDone: [
                      {
                        cond: "hasMfaTicket",
                        actions: ["saveMfaTicket"],
                        target: "#nhost.authentication.signedOut.needsMfa"
                      },
                      {
                        actions: ["saveSession", "reportTokenChanged"],
                        target: "#nhost.authentication.signedIn"
                      }
                    ],
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                },
                anonymous: {
                  invoke: {
                    src: "signInAnonymous",
                    id: "authenticateAnonymously",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                mfa: {
                  states: {
                    totp: {
                      invoke: {
                        src: "signInMfaTotp",
                        id: "signInMfaTotp",
                        onDone: {
                          actions: ["saveSession", "reportTokenChanged"],
                          target: "#nhost.authentication.signedIn"
                        },
                        onError: {
                          actions: ["saveAuthenticationError"],
                          target: "#nhost.authentication.signedOut.failed"
                        }
                      }
                    }
                  }
                },
                securityKeyEmail: {
                  invoke: {
                    src: "signInSecurityKeyEmail",
                    id: "authenticateUserWithSecurityKey",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                }
              }
            },
            signedIn: {
              type: "parallel",
              entry: ["reportSignedIn", "cleanUrl", "broadcastToken", "resetErrors"],
              on: {
                SIGNOUT: "signedOut.signingOut"
              },
              states: {
                refreshTimer: {
                  id: "timer",
                  initial: "idle",
                  states: {
                    disabled: { type: "final" },
                    stopped: {
                      always: {
                        cond: "noToken",
                        target: "idle"
                      }
                    },
                    idle: {
                      always: [
                        { cond: "isAutoRefreshDisabled", target: "disabled" },
                        {
                          cond: "hasRefreshToken",
                          target: "running"
                        }
                      ]
                    },
                    running: {
                      initial: "pending",
                      entry: "resetTimer",
                      states: {
                        pending: {
                          after: {
                            1e3: {
                              internal: !1,
                              target: "pending"
                            }
                          },
                          always: {
                            cond: "refreshTimerShouldRefresh",
                            target: "refreshing"
                          }
                        },
                        refreshing: {
                          invoke: {
                            src: "refreshToken",
                            id: "refreshToken",
                            onDone: {
                              actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                              target: "pending"
                            },
                            onError: [
                              { actions: "saveRefreshAttempt", target: "pending" }
                            ]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        token: {
          initial: "idle",
          states: {
            idle: {
              on: {
                TRY_TOKEN: "running"
              },
              initial: "noErrors",
              states: { noErrors: {}, error: {} }
            },
            running: {
              invoke: {
                src: "refreshToken",
                id: "authenticateWithToken",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: ["#nhost.authentication.signedIn", "idle.noErrors"]
                },
                onError: [
                  { cond: "isSignedIn", target: "idle.error" },
                  {
                    actions: "saveAuthenticationError",
                    target: ["#nhost.authentication.signedOut.failed", "idle.error"]
                  }
                ]
              }
            }
          }
        },
        registration: {
          initial: "incomplete",
          on: {
            SIGNED_IN: [{ cond: "isAnonymous", target: ".incomplete" }, ".complete"]
          },
          states: {
            incomplete: {
              on: {
                SIGNUP_EMAIL_PASSWORD: "emailPassword",
                SIGNUP_SECURITY_KEY: "securityKey",
                PASSWORDLESS_EMAIL: "passwordlessEmail",
                PASSWORDLESS_SMS: "passwordlessSms",
                PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp"
              },
              initial: "noErrors",
              states: {
                noErrors: {},
                needsEmailVerification: {},
                needsOtp: {},
                failed: {}
              }
            },
            emailPassword: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpEmailPassword",
                id: "signUpEmailPassword",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            securityKey: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpSecurityKey",
                id: "signUpSecurityKey",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            passwordlessEmail: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessEmail",
                id: "passwordlessEmail",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSms: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSms",
                id: "passwordlessSms",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSmsOtp: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSmsOtp",
                id: "passwordlessSmsOtp",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            complete: {
              on: {
                SIGNED_OUT: "incomplete"
              }
            }
          }
        }
      }
    },
    {
      actions: {
        reportSignedIn: w("SIGNED_IN"),
        reportSignedOut: w("SIGNED_OUT"),
        reportTokenChanged: w("TOKEN_CHANGED"),
        incrementTokenImportAttempts: h({
          importTokenAttempts: ({ importTokenAttempts: o }) => o + 1
        }),
        clearContext: h(() => (m(N, null), m(C, null), {
          ...K
        })),
        clearContextExceptRefreshToken: h(({ refreshToken: { value: o } }) => (m(N, null), {
          ...K,
          refreshToken: { value: o }
        })),
        saveSession: h({
          user: (o, { data: a }) => {
            var c;
            return ((c = a == null ? void 0 : a.session) == null ? void 0 : c.user) || null;
          },
          accessToken: (o, { data: a }) => {
            if (a.session) {
              const { accessTokenExpiresIn: c, accessToken: l } = a.session, T = new Date(Date.now() + c * 1e3);
              return m(N, T.toISOString()), {
                value: l,
                expiresAt: T
              };
            }
            return m(N, null), {
              value: null,
              expiresAt: null
            };
          },
          refreshToken: (o, { data: a }) => {
            var l;
            const c = ((l = a.session) == null ? void 0 : l.refreshToken) || null;
            return c && m(C, c), { value: c };
          }
        }),
        saveMfaTicket: h({
          mfa: (o, a) => {
            var c;
            return (c = a.data) == null ? void 0 : c.mfa;
          }
        }),
        resetTimer: h({
          refreshTimer: (o) => ({
            startedAt: new Date(),
            attempts: 0,
            lastAttempt: null
          })
        }),
        saveRefreshAttempt: h({
          refreshTimer: (o, a) => ({
            startedAt: o.refreshTimer.startedAt,
            attempts: o.refreshTimer.attempts + 1,
            lastAttempt: new Date()
          })
        }),
        saveAuthenticationError: h({
          errors: ({ errors: o }, { data: { error: a } }) => ({
            ...o,
            authentication: a
          })
        }),
        resetErrors: h({
          errors: (o) => ({}),
          importTokenAttempts: (o) => 0
        }),
        saveRegistrationError: h({
          errors: ({ errors: o }, { data: { error: a } }) => ({ ...o, registration: a })
        }),
        destroyRefreshToken: h({
          refreshToken: (o) => (m(C, null), { value: null })
        }),
        cleanUrl: () => {
          E && x("refreshToken") && (j("refreshToken"), j("type"));
        },
        broadcastToken: (o) => {
          if (E)
            try {
              new BroadcastChannel("nhost").postMessage(o.refreshToken.value);
            } catch {
            }
        }
      },
      guards: {
        isAnonymous: (o, a) => {
          var c;
          return !!((c = o.user) != null && c.isAnonymous);
        },
        isSignedIn: (o) => !!o.user && !!o.refreshToken.value && !!o.accessToken.value,
        noToken: (o) => !o.refreshToken.value,
        hasRefreshToken: (o) => !!o.refreshToken.value,
        isAutoRefreshDisabled: () => !d,
        refreshTimerShouldRefresh: (o) => {
          const { expiresAt: a } = o.accessToken;
          return a ? o.refreshTimer.lastAttempt ? Date.now() - o.refreshTimer.lastAttempt.getTime() > me * 1e3 : u && Date.now() - o.refreshTimer.startedAt.getTime() > u * 1e3 ? !0 : a.getTime() - Date.now() - 1e3 * he <= 0 : !1;
        },
        shouldRetryImportToken: (o, a) => a.data.error.status === Z || a.data.error.status >= 500,
        unverified: (o, { data: { error: a } }) => a.status === 401 && (a.message === "Email is not verified" || a.error === "unverified-user"),
        hasSession: (o, a) => {
          var c;
          return !!((c = a.data) != null && c.session);
        },
        hasMfaTicket: (o, a) => {
          var c;
          return !!((c = a.data) != null && c.mfa);
        }
      },
      services: {
        signInPassword: (o, { email: a, password: c }) => k(a) ? q(c) ? f("/signin/email-password", {
          email: a,
          password: c
        }) : Promise.reject({ error: G }) : Promise.reject({ error: R }),
        passwordlessSms: (o, { phoneNumber: a, options: c }) => {
          var l;
          return B(a) ? (l = o.user) != null && l.isAnonymous ? (console.warn(
            "Deanonymisation from a phone number is not yet implemented in hasura-auth"
          ), f(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "sms",
              phoneNumber: a,
              options: v(e, c)
            },
            {
              headers: {
                authorization: `Bearer ${o.accessToken.value}`
              }
            }
          )) : f("/signin/passwordless/sms", {
            phoneNumber: a,
            options: v(e, c)
          }) : Promise.reject({ error: Y });
        },
        passwordlessSmsOtp: (o, { phoneNumber: a, otp: c }) => B(a) ? f("/signin/passwordless/sms/otp", {
          phoneNumber: a,
          otp: c
        }) : Promise.reject({ error: Y }),
        passwordlessEmail: (o, { email: a, options: c }) => {
          var l;
          return k(a) ? (l = o.user) != null && l.isAnonymous ? f(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "email",
              email: a,
              options: v(e, c)
            },
            {
              headers: {
                authorization: `Bearer ${o.accessToken.value}`
              }
            }
          ) : f("/signin/passwordless/email", {
            email: a,
            options: v(e, c)
          }) : Promise.reject({ error: R });
        },
        signInAnonymous: (o) => f("/signin/anonymous"),
        signInMfaTotp: (o, a) => {
          var l;
          const c = a.ticket || ((l = o.mfa) == null ? void 0 : l.ticket);
          return c ? Re(c) ? f("/signin/mfa/totp", {
            ticket: c,
            otp: a.otp
          }) : Promise.reject({ error: pe }) : Promise.reject({ error: we });
        },
        signInSecurityKeyEmail: async (o, { email: a }) => {
          if (!k(a))
            throw new D(R);
          const c = await f(
            "/signin/webauthn",
            { email: a }
          );
          let l;
          try {
            l = await de(c);
          } catch (T) {
            throw new D(T);
          }
          return f("/signin/webauthn/verify", { email: a, credential: l });
        },
        refreshToken: async (o, a) => {
          const c = a.type === "TRY_TOKEN" ? a.token : o.refreshToken.value;
          return { session: await f("/token", {
            refreshToken: c
          }), error: null };
        },
        signout: (o, a) => f("/signout", {
          refreshToken: o.refreshToken.value,
          all: !!a.all
        }),
        signUpEmailPassword: async (o, { email: a, password: c, options: l }) => {
          var T;
          return k(a) ? q(c) ? (T = o.user) != null && T.isAnonymous ? f(
            "/user/deanonymize",
            {
              signInMethod: "email-password",
              email: a,
              password: c,
              options: v(e, l)
            },
            {
              headers: {
                authorization: `Bearer ${o.accessToken.value}`
              }
            }
          ) : f("/signup/email-password", {
            email: a,
            password: c,
            options: v(e, l)
          }) : Promise.reject({ error: G }) : Promise.reject({ error: R });
        },
        signUpSecurityKey: async (o, { email: a, options: c }) => {
          if (!k(a))
            return Promise.reject({ error: R });
          const l = c == null ? void 0 : c.nickname;
          l && delete c.nickname;
          const T = await f(
            "/signup/webauthn",
            { email: a, options: c }
          );
          let $;
          try {
            $ = await X(T);
          } catch (ee) {
            throw new D(ee);
          }
          return f("/signup/webauthn/verify", {
            credential: $,
            options: {
              redirectTo: c == null ? void 0 : c.redirectTo,
              nickname: l
            }
          });
        },
        importRefreshToken: async () => {
          let o = null;
          if (E) {
            const c = x("refreshToken") || null;
            if (c)
              try {
                return { session: await f("/token", {
                  refreshToken: c
                }), error: null };
              } catch (l) {
                o = l.error;
              }
            else {
              const l = x("error");
              if (l)
                return Promise.reject({
                  session: null,
                  error: {
                    status: y,
                    error: l,
                    message: x("errorDescription") || l
                  }
                });
            }
          }
          const a = await p(C);
          if (a)
            try {
              return { session: await f("/token", {
                refreshToken: a
              }), error: null };
            } catch (c) {
              o = c.error;
            }
          return o ? Promise.reject({ error: o, session: null }) : { error: null, session: null };
        }
      },
      delays: {
        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: o }) => o < 5 ? 1e3 : 5e3
      }
    }
  );
};
class _e {
  constructor({
    clientStorageType: e = "web",
    autoSignIn: t = !0,
    autoRefreshToken: s = !0,
    start: n = !0,
    backendUrl: i,
    clientUrl: u,
    devTools: d,
    ...E
  }) {
    A(this, "backendUrl");
    A(this, "clientUrl");
    A(this, "machine");
    A(this, "_interpreter");
    A(this, "_channel");
    A(this, "_subscriptions", /* @__PURE__ */ new Set());
    if (this.backendUrl = i, this.clientUrl = u, this.machine = ke({
      ...E,
      backendUrl: i,
      clientUrl: u,
      clientStorageType: e,
      autoSignIn: t,
      autoRefreshToken: s
    }), n && (this.interpreter = te(this.machine, { devTools: d }), this.interpreter.start()), typeof window < "u" && t)
      try {
        this._channel = new BroadcastChannel("nhost"), this._channel.addEventListener("message", (p) => {
          var S;
          const m = (S = this.interpreter) == null ? void 0 : S.getSnapshot().context.refreshToken.value;
          this.interpreter && p.data !== m && this.interpreter.send("TRY_TOKEN", { token: p.data });
        });
      } catch {
      }
  }
  get interpreter() {
    return this._interpreter;
  }
  set interpreter(e) {
    this._interpreter = e, e && this._subscriptions.forEach((t) => t(this));
  }
  onStart(e) {
    this.interpreter ? e(this) : this._subscriptions.add(e);
  }
}
const F = typeof window < "u";
class Oe extends _e {
  constructor({
    ...e
  }) {
    super({
      ...e,
      autoSignIn: F && e.autoSignIn,
      autoRefreshToken: F && e.autoRefreshToken,
      clientStorageType: "cookie"
    });
  }
}
const Ye = Oe, je = async ({ backendUrl: r, interpreter: e }, t) => {
  const s = O(r);
  try {
    const { data: n } = await s.post(
      "/user/webauthn/add",
      {},
      {
        headers: {
          authorization: `Bearer ${e == null ? void 0 : e.getSnapshot().context.accessToken.value}`
        }
      }
    );
    let i;
    try {
      i = await X(n);
    } catch (d) {
      throw new D(d);
    }
    const { data: u } = await s.post(
      "/user/webauthn/verify",
      { credential: i, nickname: t },
      {
        headers: {
          authorization: `Bearer ${e == null ? void 0 : e.getSnapshot().context.accessToken.value}`
        }
      }
    );
    return { key: u, isError: !1, error: null, isSuccess: !0 };
  } catch (n) {
    const { error: i } = n;
    return { isError: !0, error: i, isSuccess: !1 };
  }
}, Be = async (r, e, t) => new Promise((s) => {
  r.send("REQUEST", {
    email: e,
    options: t
  }), r.onTransition((n) => {
    n.matches({ idle: "error" }) ? s({ error: n.context.error, isError: !0, needsEmailVerification: !1 }) : n.matches({ idle: "success" }) && s({ error: null, isError: !1, needsEmailVerification: !0 });
  });
}), Fe = async (r, e, t) => new Promise((s) => {
  r.send("REQUEST", {
    password: e,
    ticket: t
  }), r.onTransition((n) => {
    n.matches({ idle: "error" }) ? s({ error: n.context.error, isError: !0, isSuccess: !1 }) : n.matches({ idle: "success" }) && s({ error: null, isError: !1, isSuccess: !0 });
  });
}), ze = (r) => new Promise((e) => {
  r.send("GENERATE"), r.onTransition((t) => {
    t.matches("generated") ? e({
      error: null,
      isError: !1,
      isGenerated: !0,
      qrCodeDataUrl: t.context.imageUrl || ""
    }) : t.matches({ idle: "error" }) && e({
      error: t.context.error || null,
      isError: !0,
      isGenerated: !1,
      qrCodeDataUrl: ""
    });
  });
}), He = (r, e) => new Promise((t) => {
  r.send("ACTIVATE", {
    activeMfaType: "totp",
    code: e
  }), r.onTransition((s) => {
    s.matches({ generated: "activated" }) ? t({ error: null, isActivated: !0, isError: !1 }) : s.matches({ generated: { idle: "error" } }) && t({ error: s.context.error, isActivated: !1, isError: !0 });
  });
}), Qe = async (r, e, t) => new Promise((s) => {
  r.send("REQUEST", {
    email: e,
    options: t
  }), r.onTransition((n) => {
    n.matches({ idle: "error" }) ? s({ error: n.context.error, isError: !0, isSent: !1 }) : n.matches({ idle: "success" }) && s({ error: null, isError: !1, isSent: !0 });
  });
}), Xe = (r, e, t) => new Promise((s) => {
  r.send("REQUEST", {
    email: e,
    options: t
  }), r.onTransition((n) => {
    n.matches({ idle: "error" }) ? s({ error: n.context.error, isError: !0, isSent: !1 }) : n.matches({ idle: "success" }) && s({ error: null, isError: !1, isSent: !0 });
  });
}), Ze = (r) => new Promise((e) => {
  const { changed: t } = r.send("SIGNIN_ANONYMOUS");
  t || e({
    isSuccess: !1,
    isError: !0,
    error: I,
    user: null,
    accessToken: null
  }), r.onTransition((s) => {
    s.matches({ authentication: "signedIn" }) && e({
      isSuccess: !0,
      isError: !1,
      error: null,
      user: s.context.user,
      accessToken: s.context.accessToken.value
    }), s.matches({ authentication: { signedOut: "failed" } }) && e({
      isSuccess: !1,
      isError: !0,
      error: s.context.errors.authentication || null,
      user: null,
      accessToken: null
    });
  });
}), Je = (r, e, t) => new Promise((s) => {
  const { changed: n, context: i } = r.send("SIGNIN_PASSWORD", {
    email: e,
    password: t
  });
  if (!n)
    return s({
      accessToken: i.accessToken.value,
      error: I,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: i.user
    });
  r.onTransition((u) => {
    u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? s({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      needsMfaOtp: !1,
      mfa: null,
      user: null
    }) : u.matches({ authentication: { signedOut: "needsMfa" } }) ? s({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !0,
      mfa: u.context.mfa,
      user: null
    }) : u.matches({ authentication: { signedOut: "failed" } }) ? s({
      accessToken: null,
      error: u.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: null
    }) : u.matches({ authentication: "signedIn" }) && s({
      accessToken: u.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      needsMfaOtp: !1,
      mfa: null,
      user: u.context.user
    });
  });
}), er = (r, e, t) => new Promise((s) => {
  const { changed: n } = r.send("PASSWORDLESS_EMAIL", {
    email: e,
    options: t
  });
  if (!n)
    return s({
      error: I,
      isError: !0,
      isSuccess: !1
    });
  r.onTransition((i) => {
    i.matches("registration.incomplete.failed") ? s({
      error: i.context.errors.registration || null,
      isError: !0,
      isSuccess: !1
    }) : i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) && s({ error: null, isError: !1, isSuccess: !0 });
  });
}), rr = (r, e) => new Promise((t) => {
  const { changed: s, context: n } = r.send({ type: "SIGNIN_SECURITY_KEY_EMAIL", email: e });
  if (!s)
    return t({
      accessToken: n.accessToken.value,
      error: I,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: n.user
    });
  r.onTransition((i) => {
    i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? t({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : i.matches({ authentication: { signedOut: "failed" } }) ? t({
      accessToken: null,
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : i.matches({ authentication: "signedIn" }) && t({
      accessToken: i.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: i.context.user
    });
  });
}), sr = (r, e, t) => new Promise((s) => {
  const { changed: n, context: i } = r.send("SIGNIN_MFA_TOTP", {
    otp: e,
    ticket: t
  });
  if (!n)
    return s({
      accessToken: i.accessToken.value,
      error: I,
      isError: !0,
      isSuccess: !1,
      user: i.user
    });
  r.onTransition((u) => {
    u.matches({ authentication: { signedOut: "failed" } }) ? s({
      accessToken: null,
      error: u.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      user: null
    }) : u.matches({ authentication: "signedIn" }) && s({
      accessToken: u.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      user: u.context.user
    });
  });
}), tr = (r, e, t) => new Promise((s) => {
  const { changed: n } = r.send("PASSWORDLESS_SMS", { phoneNumber: e, options: t });
  if (!n)
    return s({
      error: I,
      isError: !0,
      isSuccess: !1,
      needsOtp: !1
    });
  r.onTransition((i) => {
    i.matches("registration.incomplete.needsOtp") ? s({
      error: null,
      isError: !1,
      isSuccess: !1,
      needsOtp: !0
    }) : i.matches("registration.incomplete.failed") && s({
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      needsOtp: !1
    });
  });
}), nr = (r, e, t) => new Promise((s) => {
  const { changed: n } = r.send({ type: "PASSWORDLESS_SMS_OTP", phoneNumber: e, otp: t });
  if (!n)
    return s({
      error: I,
      isError: !0,
      isSuccess: !1,
      user: null,
      accessToken: null
    });
  r.onTransition((i) => {
    i.matches({ authentication: "signedIn" }) ? s({
      error: null,
      isError: !1,
      isSuccess: !0,
      user: i.context.user,
      accessToken: i.context.accessToken.value
    }) : i.matches({ registration: { incomplete: "failed" } }) && s({
      error: i.context.errors.authentication || null,
      isError: !0,
      isSuccess: !1,
      user: null,
      accessToken: null
    });
  });
}), ir = async (r, e) => new Promise((t) => {
  const { event: s } = r.send("SIGNOUT", { all: e });
  if (s.type !== "SIGNED_OUT")
    return t({ isSuccess: !1, isError: !0, error: Te });
  r.onTransition((n) => {
    n.matches({ authentication: { signedOut: "success" } }) ? t({ isSuccess: !0, isError: !1, error: null }) : n.matches("authentication.signedOut.failed") && t({ isSuccess: !1, isError: !0, error: n.context.errors.signout || null });
  });
}), or = (r, e, t, s) => new Promise((n) => {
  const { changed: i, context: u } = r.send("SIGNUP_EMAIL_PASSWORD", {
    email: e,
    password: t,
    options: s
  });
  if (!i)
    return n({
      error: I,
      accessToken: u.accessToken.value,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: u.user
    });
  r.onTransition((d) => {
    d.matches("registration.incomplete.failed") ? n({
      accessToken: null,
      error: d.context.errors.registration || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : d.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? n({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : d.matches({ authentication: "signedIn", registration: "complete" }) && n({
      accessToken: d.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: d.context.user
    });
  });
}), ar = (r, e, t) => new Promise((s) => {
  const { changed: n, context: i } = r.send("SIGNUP_SECURITY_KEY", {
    email: e,
    options: t
  });
  if (!n)
    return s({
      error: I,
      accessToken: i.accessToken.value,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: i.user
    });
  r.onTransition((u) => {
    u.matches("registration.incomplete.failed") ? s({
      accessToken: null,
      error: u.context.errors.registration || null,
      isError: !0,
      isSuccess: !1,
      needsEmailVerification: !1,
      user: null
    }) : u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? s({
      accessToken: null,
      error: null,
      isError: !1,
      isSuccess: !1,
      needsEmailVerification: !0,
      user: null
    }) : u.matches({ authentication: "signedIn", registration: "complete" }) && s({
      accessToken: u.context.accessToken.value,
      error: null,
      isError: !1,
      isSuccess: !0,
      needsEmailVerification: !1,
      user: u.context.user
    });
  });
});
export {
  _e as AuthClient,
  Ye as AuthClientSSR,
  Oe as AuthCookieClient,
  D as CodifiedError,
  Me as EMAIL_NEEDS_VERIFICATION,
  R as INVALID_EMAIL_ERROR,
  ge as INVALID_MFA_CODE_ERROR,
  pe as INVALID_MFA_TICKET_ERROR,
  Ee as INVALID_MFA_TYPE_ERROR,
  G as INVALID_PASSWORD_ERROR,
  Y as INVALID_PHONE_NUMBER_ERROR,
  Ve as INVALID_REFRESH_TOKEN,
  Ke as INVALID_SIGN_IN_METHOD,
  fe as MIN_PASSWORD_LENGTH,
  Z as NETWORK_ERROR_CODE,
  N as NHOST_JWT_EXPIRES_AT_KEY,
  C as NHOST_REFRESH_TOKEN_KEY,
  we as NO_MFA_TICKET_ERROR,
  xe as NO_REFRESH_TOKEN,
  J as OTHER_ERROR_CODE,
  me as REFRESH_TOKEN_RETRY_INTERVAL,
  P as STATE_ERROR_CODE,
  De as TOKEN_REFRESHER_RUNNING_ERROR,
  he as TOKEN_REFRESH_MARGIN,
  I as USER_ALREADY_SIGNED_IN,
  Ue as USER_NOT_ANONYMOUS,
  Te as USER_UNAUTHENTICATED,
  y as VALIDATION_ERROR_CODE,
  He as activateMfaPromise,
  je as addSecurityKeyPromise,
  Be as changeEmailPromise,
  Fe as changePasswordPromise,
  ke as createAuthMachine,
  Le as createChangeEmailMachine,
  Ge as createChangePasswordMachine,
  qe as createEnableMfaMachine,
  We as createResetPasswordMachine,
  $e as createSendVerificationEmailMachine,
  Ae as encodeQueryParameters,
  ze as generateQrCodePromise,
  x as getParameterByName,
  ve as localStorageGetter,
  Ie as localStorageSetter,
  j as removeParameterFromWindow,
  Qe as resetPasswordPromise,
  v as rewriteRedirectTo,
  Xe as sendVerificationEmailPromise,
  Ze as signInAnonymousPromise,
  Je as signInEmailPasswordPromise,
  er as signInEmailPasswordlessPromise,
  rr as signInEmailSecurityKeyPromise,
  sr as signInMfaTotpPromise,
  nr as signInSmsPasswordlessOtpPromise,
  tr as signInSmsPasswordlessPromise,
  ir as signOutPromise,
  or as signUpEmailPasswordPromise,
  ar as signUpEmailSecurityKeyPromise
};
//# sourceMappingURL=index.esm.js.map
