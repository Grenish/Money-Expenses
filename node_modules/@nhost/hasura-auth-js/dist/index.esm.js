var m = Object.defineProperty;
var E = (i, e, t) => e in i ? m(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var u = (i, e, t) => (E(i, typeof e != "symbol" ? e + "" : e, t), t);
import _ from "jwt-decode";
import { interpret as c } from "xstate";
import { AuthClient as S, signUpEmailSecurityKeyPromise as I, signUpEmailPasswordPromise as d, signInAnonymousPromise as N, encodeQueryParameters as P, rewriteRedirectTo as A, signInEmailPasswordPromise as k, EMAIL_NEEDS_VERIFICATION as R, signInEmailSecurityKeyPromise as U, signInEmailPasswordlessPromise as f, signInSmsPasswordlessOtpPromise as O, signInSmsPasswordlessPromise as w, signInMfaTotpPromise as C, INVALID_SIGN_IN_METHOD as b, signOutPromise as K, createResetPasswordMachine as M, resetPasswordPromise as v, createChangePasswordMachine as D, changePasswordPromise as H, createSendVerificationEmailMachine as V, sendVerificationEmailPromise as G, createChangeEmailMachine as x, changeEmailPromise as F, addSecurityKeyPromise as L, NO_REFRESH_TOKEN as $, TOKEN_REFRESHER_RUNNING_ERROR as j, INVALID_REFRESH_TOKEN as z } from "@nhost/core";
const W = () => typeof window < "u", l = (i) => !i || !i.accessToken.value || !i.refreshToken.value || !i.accessToken.expiresAt || !i.user ? null : {
  accessToken: i.accessToken.value,
  accessTokenExpiresIn: (i.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
  refreshToken: i.refreshToken.value,
  user: i.user
}, a = ({
  accessToken: i,
  isError: e,
  user: t,
  error: n
}) => e ? {
  session: null,
  error: n
} : t && i ? {
  session: { accessToken: i, accessTokenExpiresIn: 0, refreshToken: "", user: t },
  error: null
} : { session: null, error: null };
class q {
  constructor({
    url: e,
    autoRefreshToken: t = !0,
    autoSignIn: n = !0,
    autoLogin: r,
    clientStorage: s,
    clientStorageType: o,
    clientStorageGetter: g,
    clientStorageSetter: y,
    refreshIntervalTime: p,
    start: T = !0
  }) {
    u(this, "_client");
    u(this, "url");
    var h;
    this.url = e, this._client = new S({
      backendUrl: e,
      clientUrl: typeof window < "u" && ((h = window.location) == null ? void 0 : h.origin) || "",
      autoRefreshToken: t,
      autoSignIn: typeof r == "boolean" ? r : n,
      start: T,
      clientStorage: s,
      clientStorageType: o,
      clientStorageGetter: g,
      clientStorageSetter: y,
      refreshIntervalTime: p
    });
  }
  async signUp(e) {
    const t = await this.waitUntilReady(), { email: n, options: r } = e;
    return "securityKey" in e ? a(
      await I(t, n, r)
    ) : a(
      await d(t, n, e.password, r)
    );
  }
  async signIn(e) {
    const t = await this.waitUntilReady();
    if (!e) {
      const n = await N(t);
      return { ...a(n), mfa: null };
    }
    if ("provider" in e) {
      const { provider: n, options: r } = e, s = P(
        `${this._client.backendUrl}/signin/provider/${n}`,
        A(this._client.clientUrl, r)
      );
      return W() && (window.location.href = s), { providerUrl: s, provider: n, session: null, mfa: null, error: null };
    }
    if ("email" in e && "password" in e) {
      const n = await k(t, e.email, e.password);
      return n.needsEmailVerification ? { session: null, mfa: null, error: R } : n.needsMfaOtp ? {
        session: null,
        mfa: n.mfa,
        error: null
      } : { ...a(n), mfa: null };
    }
    if ("email" in e && "securityKey" in e) {
      if (e.securityKey !== !0)
        throw Error("securityKey must be true");
      const n = await U(t, e.email);
      return { ...a(n), mfa: null };
    }
    if ("email" in e) {
      const { email: n, options: r } = e, { error: s } = await f(t, n, r);
      return {
        session: null,
        mfa: null,
        error: s
      };
    }
    if ("phoneNumber" in e && "otp" in e) {
      const n = await O(t, e.phoneNumber, e.otp);
      return { ...a(n), mfa: null };
    }
    if ("phoneNumber" in e) {
      const { error: n } = await w(
        t,
        e.phoneNumber,
        e.options
      );
      return { error: n, mfa: null, session: null };
    }
    if ("otp" in e) {
      const n = await C(t, e.otp, e.ticket);
      return { ...a(n), mfa: null };
    }
    return { error: b, mfa: null, session: null };
  }
  async signOut(e) {
    const t = await this.waitUntilReady(), { error: n } = await K(t, e == null ? void 0 : e.all);
    return { error: n };
  }
  async resetPassword({ email: e, options: t }) {
    const n = c(M(this._client)).start(), { error: r } = await v(n, e, t);
    return { error: r };
  }
  async changePassword({
    newPassword: e,
    ticket: t
  }) {
    const n = c(D(this._client)).start(), { error: r } = await H(n, e, t);
    return { error: r };
  }
  async sendVerificationEmail({
    email: e,
    options: t
  }) {
    const n = c(V(this._client)).start(), { error: r } = await G(n, e, t);
    return { error: r };
  }
  async changeEmail({ newEmail: e, options: t }) {
    const n = c(x(this._client)).start(), { error: r } = await F(n, e, t);
    return { error: r };
  }
  async deanonymize(e) {
    const t = await this.waitUntilReady();
    if (e.signInMethod === "passwordless") {
      if (e.connection === "email") {
        const { error: n } = await f(
          t,
          e.email,
          e.options
        );
        return { error: n };
      }
      if (e.connection === "sms") {
        const { error: n } = await w(
          t,
          e.phoneNumber,
          e.options
        );
        return { error: n };
      }
    }
    if (e.signInMethod === "email-password") {
      const { error: n } = await d(
        t,
        e.email,
        e.password,
        e.options
      );
      return { error: n };
    }
    throw Error("Unknown deanonymization method");
  }
  async addSecurityKey(e) {
    const { error: t, key: n } = await L(this._client, e);
    return { error: t, key: n };
  }
  onTokenChanged(e) {
    const t = (n) => n.onTransition(({ event: r, context: s }) => {
      r.type === "TOKEN_CHANGED" && e(l(s));
    });
    if (this._client.interpreter) {
      const n = t(this._client.interpreter);
      return () => n.stop();
    } else
      return this._client.onStart((n) => {
        t(n.interpreter);
      }), () => {
        console.log(
          "onTokenChanged was added before the interpreter started. Cannot unsubscribe listener."
        );
      };
  }
  onAuthStateChanged(e) {
    const t = (n) => n.onTransition(({ event: r, context: s }) => {
      (r.type === "SIGNED_IN" || r.type === "SIGNED_OUT") && e(r.type, l(s));
    });
    if (this._client.interpreter) {
      const n = t(this._client.interpreter);
      return () => n.stop();
    } else
      return this._client.onStart((n) => {
        t(n.interpreter);
      }), () => {
        console.log(
          "onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener."
        );
      };
  }
  isAuthenticated() {
    var e;
    return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({ authentication: "signedIn" }));
  }
  async isAuthenticatedAsync() {
    return (await this.waitUntilReady()).getSnapshot().matches({ authentication: "signedIn" });
  }
  getAuthenticationStatus() {
    var t;
    const e = ((t = this.client.interpreter) == null ? void 0 : t.getSnapshot().context.importTokenAttempts) || 0;
    return this.isReady() ? { isAuthenticated: this.isAuthenticated(), isLoading: !1, connectionAttempts: e } : {
      isAuthenticated: !1,
      isLoading: !0,
      connectionAttempts: e
    };
  }
  getJWTToken() {
    return this.getAccessToken();
  }
  getAccessToken() {
    var e, t;
    return (t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? t : void 0;
  }
  getDecodedAccessToken() {
    const e = this.getAccessToken();
    return e ? _(e) : null;
  }
  getHasuraClaims() {
    var e;
    return ((e = this.getDecodedAccessToken()) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
  }
  getHasuraClaim(e) {
    var t;
    return ((t = this.getHasuraClaims()) == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
  }
  async refreshSession(e) {
    try {
      const t = await this.waitUntilReady();
      return new Promise((n) => {
        const r = e || t.getSnapshot().context.refreshToken.value;
        if (!r)
          return n({ session: null, error: $ });
        const { changed: s } = t.send("TRY_TOKEN", { token: r });
        if (!s)
          return n({ session: null, error: j });
        t.onTransition((o) => {
          o.matches({ token: { idle: "error" } }) ? n({
            session: null,
            error: z
          }) : o.event.type === "TOKEN_CHANGED" && n({ session: l(o.context), error: null });
        });
      });
    } catch (t) {
      return { session: null, error: t.message };
    }
  }
  getSession() {
    var e, t;
    return l((t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : t.context);
  }
  getUser() {
    var e, t, n;
    return ((n = (t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : t.context) == null ? void 0 : n.user) || null;
  }
  waitUntilReady() {
    const t = this._client.interpreter;
    if (!t)
      throw Error("Auth interpreter not set");
    return t.getSnapshot().hasTag("loading") ? new Promise((n, r) => {
      let s = setTimeout(
        () => r(`The state machine is not yet ready after ${15} seconds.`),
        15e3
      );
      t.onTransition((o) => {
        if (!o.hasTag("loading"))
          return clearTimeout(s), n(t);
      });
    }) : Promise.resolve(t);
  }
  isReady() {
    var e, t;
    return !((t = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && t.hasTag("loading"));
  }
  get client() {
    return this._client;
  }
}
export {
  q as HasuraAuthClient
};
//# sourceMappingURL=index.esm.js.map
