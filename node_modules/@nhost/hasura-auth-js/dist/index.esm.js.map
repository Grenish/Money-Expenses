{"version":3,"file":"index.esm.js","sources":["../src/utils/helpers.ts","../src/hasura-auth-client.ts"],"sourcesContent":["import { AuthContext, NhostSession, SessionActionHandlerResult, SignUpResponse } from '@nhost/core'\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (\n    !context ||\n    !context.accessToken.value ||\n    !context.refreshToken.value ||\n    !context.accessToken.expiresAt ||\n    !context.user\n  ) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: '', user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\n\nimport {\n  addSecurityKeyPromise,\n  AuthClient,\n  AuthInterpreter,\n  changeEmailPromise,\n  ChangeEmailResponse,\n  changePasswordPromise,\n  ChangePasswordResponse,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine,\n  DeanonymizeResponse,\n  EMAIL_NEEDS_VERIFICATION,\n  encodeQueryParameters,\n  ErrorPayload,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostSessionResponse,\n  NO_REFRESH_TOKEN,\n  resetPasswordPromise,\n  ResetPasswordResponse,\n  rewriteRedirectTo,\n  SecurityKey,\n  sendVerificationEmailPromise,\n  SendVerificationEmailResponse,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  SignInResponse,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  SignOutResponse,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  SignUpResponse,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from '@nhost/core'\n\nimport { getAuthenticationResult, getSession, isBrowser } from './utils/helpers'\nimport {\n  AuthChangedFunction,\n  ChangeEmailParams,\n  ChangePasswordParams,\n  DeanonymizeParams,\n  NhostAuthConstructorParams,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  SendVerificationEmailParams,\n  SignInParams,\n  SignUpParams\n} from './utils/types'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    autoLogin,\n    clientStorage,\n    clientStorageType,\n    clientStorageGetter,\n    clientStorageSetter,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn: typeof autoLogin === 'boolean' ? autoLogin : autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      clientStorageGetter,\n      clientStorageSetter,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: ErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    const listen = (interpreter: AuthInterpreter) =>\n      interpreter.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n    if (this._client.interpreter) {\n      const subscription = listen(this._client.interpreter)\n      return () => subscription.stop()\n    } else {\n      this._client.onStart((client) => {\n        listen(client.interpreter as AuthInterpreter)\n      })\n      return () => {\n        console.log(\n          'onAuthStateChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * @internal\n   * @deprecated Use `nhost.auth.getAccessToken()` instead.\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n\n  getJWTToken(): string | undefined {\n    return this.getAccessToken()\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["isBrowser","getSession","context","getAuthenticationResult","accessToken","isError","user","error","HasuraAuthClient","url","autoRefreshToken","autoSignIn","autoLogin","clientStorage","clientStorageType","clientStorageGetter","clientStorageSetter","refreshIntervalTime","start","__publicField","AuthClient","_a","params","interpreter","email","options","signUpEmailSecurityKeyPromise","signUpEmailPasswordPromise","anonymousResult","signInAnonymousPromise","provider","providerUrl","encodeQueryParameters","rewriteRedirectTo","res","signInEmailPasswordPromise","EMAIL_NEEDS_VERIFICATION","signInEmailSecurityKeyPromise","signInEmailPasswordlessPromise","signInSmsPasswordlessOtpPromise","signInSmsPasswordlessPromise","signInMfaTotpPromise","INVALID_SIGN_IN_METHOD","signOutPromise","service","interpret","createResetPasswordMachine","resetPasswordPromise","newPassword","ticket","createChangePasswordMachine","changePasswordPromise","createSendVerificationEmailMachine","sendVerificationEmailPromise","newEmail","createChangeEmailMachine","changeEmailPromise","nickname","key","addSecurityKeyPromise","fn","listen","event","subscription","client","connectionAttempts","_b","jwt","jwt_decode","name","refreshToken","resolve","token","NO_REFRESH_TOKEN","changed","TOKEN_REFRESHER_RUNNING_ERROR","state","INVALID_REFRESH_TOKEN","_c","reject","timer"],"mappings":"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"}